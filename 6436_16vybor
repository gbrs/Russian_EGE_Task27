'''
sms-голосование за (максимум) 16 пар.
Результаты голосования получены в виде номеров пар.
Вывести список всех пар в порядке невозрастания количества голосов
с указанием количества отданных за них голосов (кроме пар с нулевыми результатами)
'''

'''
Подсчитываем голоса в счетчики в массиве на 16 элементов. 
После ввода одновременная сортировка массивов номеров пар и количества голосов. 
Затем выводится список пар с указанием количества голосов
'''

# делаем массивы: номеров пар и для подсчета голосов
Count = [0] * 16
Names = [0] * 16

# заполняем массив пар номерами с 1 по 16. А можно и так: Names = list(range(1, 17))
for i in range(16):
    Names[i] = i + 1

# количество голосующих:
N = int(input())

# считываем номера пар из sms-ок и накручиваем соответствующие счетчики
for i in range(N):
    t = int(input())
    Count[t - 1] += 1

# Сортируем выбором массив Count (и Names) в порядке убывания значений массива Count.
# Слева у нас будет накапливаться отсортированная часть списка.
# Сперва на левую крайнюю позицию найдем максимальное число. Потом найдём максимальное
# среди оставшихся и поместим его во вторую слева ячейку и т.д.
# Для этого бежим до конца по неотсортированной части массива и запоминаем индекс
# самого большого элемента из неотсортированных. Затем, поменяв местами значения,
# присоединим наибольший элемент к отсортированной части списка
for i in range(15):
    # print(i, Count, Names)  # для демонстрации работы алгоритма
    index_max = i
    for j in range(i, 16):
        if Count[j] > Count[index_max]:
            index_max = j
            # print(index_max)  # для демонстрации работы алгоритма
    Count[i], Count[index_max] = Count[index_max], Count[i]
    Names[i], Names[index_max] = Names[index_max], Names[i]

# вывод номеров пар и значений, за исключением нулевых
for i in range(16):
    if Count[i] > 0:
        print(Names[i], Count[i])
