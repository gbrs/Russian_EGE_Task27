'''
Положительные целые числа раз в минуту.
Необходимо вычислить «бета-значение» – минимальное чётное произведение двух показаний,
между моментами передачи которых прошло не менее 6 минут.
Если получить такое произведение не удаётся, ответ считается равным –1.
'''

'''
Чтобы произведение было чётным, хотя бы один сомножитель должен быть чётным. 
По мере ввода данных надо знать абсолютное минимальное и чётное минимальное показания 
(с учетом правила 6). Каждое вновь вводимое показание умножать на соответствующий 
(четный/нечетный) минимум. Запоминать минимальное из всех таких произведений. 
Для этого сохраняем 2 матрицы по 6 элементов с числами, 
которые будут абсолютными/четными минимумами через 6 шагов.
'''

s = 6  # требуемое расстояние между показаниями
amax = 1001  # больше максимально возможного показания
N = int(input())  # количество вводимых значений

# создаем две матрицы: для абсолютно минимальных и четных минимальных
MN = [0] * 6  # текущие минимумы последних s элементов
MN2 = [0] * 6  # чётные минимумы последних s элементов

mn = amax  # минимальное показание инициализируем 1001
mn2 = amax  # минимальное чётное показание инициализируем 1001

# вводим первые 6 чисел и каждый раз определяем минимальные на данный момент числа
# и записываем их в соответствующие массивы
for i in range(s):
    a = int(input())  # текущее вводимое значение
    mn = min(mn, a)
    if a % 2 == 0:
        mn2 = min(mn2, a)
    MN[i] = mn
    MN2[i] = mn2

minimult = amax * amax  # минимальное значение произведения инициализиируем 1001 * 1001

# вводим остальные числа, заменяя по необходимости элементы в массивах кратные i % s
for i in range(s, N):
    a = int(input())
    if a % 2 == 0:  # если текущее число четное
        t = a * MN[i % s]  # текущее произведение с абсолютно минимальным
    elif mn2 < amax:  # если текущее число НЕчетное и ранее уже был найден четный минимум
        t = a * MN2[i % s]
    else:
        t = amax * amax  # если пока не было найденого четного минимума
    minimult = min(minimult, t)

    # если текущее значение минимально, то заменям соответствующие минимумы.
    # заменяем значения в массиве минимумов текущими минимумами,
    # не проверяя: мы же минимумы текущие все равно туда вставляем
    mn = min(mn, a)
    if a % 2 == 0:
        mn2 = min(mn2, a)
    MN[i % s] = mn
    MN2[i % s] = mn2

# 'Если получить такое произведение не удаётся, ответ считается равным –1'
if minimult == amax * amax:  # произведение так и не изменилось за все время
    minimult = -1

print(minimult)
