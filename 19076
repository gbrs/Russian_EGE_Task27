'''
На вход программы поступает последовательность из n целых положительных чисел. Рассматриваются все пары элементов
последовательности ai и aj, такие что i < j и ai > aj. Среди пар, удовлетворяющих этому условию, необходимо найти и
напечатать любую из пар с максимальной суммой элементов, которая делится на m = 120.
Описание входных и выходных данных
В первой строке входных данных задаётся количество чисел n (2 ≤ n ≤ 12 000).
В каждой из последующих n строк записано одно целое положительное число, не превышающее 10 000.
В качестве результата программа должна напечатать элементы искомой пары. Гарантируется что хотя бы одна такая пара есть.

Пример входных данных: 6 60 140 61 100 300 59. Выходные: 140 100
'''

'''Сумма двух чисел (ai и aj) делится на m, если сумма остатков этих чисел от деления на m будет равна или m, или 0. 
Для каждой из 120 величин остатка от деления на m будем хранить максимальное число среди уже просмотренных элементов в 
массиве r длиной m. Изначально всем элементам массива r присвоим значение 0. Все значения при этом можно не хранить, 
только 120. Каждое очередное число a будем рассматривать как возможный правый элемент искомой пары. a % m = p. Находим 
в массиве r парный элемент r[m–p] (сумма с которым кратна m). Проверяем больше ли парное число, чем текущее ("ai > aj"). 
Если их сумма больше предыдущей запомненной пары left + right, то заменим эту пару на новонайденую. При этом если 
остаток от деления a на m равен 0, то рассматривать надо пару a и r[0]. По окончании обработки элемента a необходимо 
обновить элемент r[p] значением a, если a > r[p].
'''

r = [0] * 120  # создание служебного массива для максимальных значений для каждого из остатков
# обнуление переменных для записи пары наибольших чисел:
left = 0
right = 0
# ввод количества элементов:
n = int(input())

# ввод значений с одновременным поиском искомой пары:
for i in range(n):
    a = int(input())  # переменная для каждого текущего элемента последовательности
    p = a % 120  # остаток от деления текущего числа на 120
    if p == 0:
        p = 120
    else:
        if (r[120 - p]) > a and (r[120 - p] + a > left + right):
            # обновление пары с максимальной суммой:
            left = r[120 - p]
            right = a
    # обновление элемента r для соответствующего остатка:
    if a > r[p]:  # если текущий элемент наибольший из уже просмотренных (с этаким остатком от деления)
        r[p] = a

print(left, right)

'''Красивый способ избавиться от проверки p == 0 (а значит целого блока if):

if r[(120 - p) % 120] > a and r[(120 - p) % 120] + a > left + right:
    left = r[(m - p) % m]

простой до элегантности способ:

if (p == 0):
    p = m
if r[m - p] > a ...
'''


